// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: agent.service.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "duraflow";

/** Task lifecycle: PENDING → RUNNING → COMPLETED/FAILED/CANCELLED */
export enum TaskStatus {
  TASK_STATUS_UNSPECIFIED = 0,
  PENDING = 1,
  RUNNING = 2,
  COMPLETED = 3,
  FAILED = 4,
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function taskStatusFromJSON(object: any): TaskStatus {
  switch (object) {
    case 0:
    case "TASK_STATUS_UNSPECIFIED":
      return TaskStatus.TASK_STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return TaskStatus.PENDING;
    case 2:
    case "RUNNING":
      return TaskStatus.RUNNING;
    case 3:
    case "COMPLETED":
      return TaskStatus.COMPLETED;
    case 4:
    case "FAILED":
      return TaskStatus.FAILED;
    case 5:
    case "CANCELLED":
      return TaskStatus.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskStatus.UNRECOGNIZED;
  }
}

export function taskStatusToJSON(object: TaskStatus): string {
  switch (object) {
    case TaskStatus.TASK_STATUS_UNSPECIFIED:
      return "TASK_STATUS_UNSPECIFIED";
    case TaskStatus.PENDING:
      return "PENDING";
    case TaskStatus.RUNNING:
      return "RUNNING";
    case TaskStatus.COMPLETED:
      return "COMPLETED";
    case TaskStatus.FAILED:
      return "FAILED";
    case TaskStatus.CANCELLED:
      return "CANCELLED";
    case TaskStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubmitTaskRequest {
  workflowName: string;
  /** JSON-encoded */
  input: Uint8Array;
}

export interface SubmitTaskResponse {
  taskId: string;
}

export interface GetTaskStatusRequest {
  taskId: string;
}

export interface GetTaskStatusResponse {
  status: TaskStatus;
  /** JSON-encoded */
  output: Uint8Array;
  /** JSON-encoded */
  error: Uint8Array;
}

export interface CancelTaskRequest {
  taskId: string;
}

export interface CancelTaskResponse {
  /** False if already completed/failed */
  success: boolean;
}

/** Step memoization messages */
export interface GetStepResultRequest {
  taskId: string;
  stepKey: string;
}

export interface GetStepResultResponse {
  found: boolean;
  /** 'pending', 'running', 'completed', 'failed' */
  status: string;
  /** JSON-encoded result (only if completed) */
  output: Uint8Array;
}

export interface SaveStepResultRequest {
  taskId: string;
  stepKey: string;
  /** JSON-encoded result */
  output: Uint8Array;
}

export interface SaveStepResultResponse {
  stepId: string;
}

export interface FailStepRequest {
  taskId: string;
  stepKey: string;
  error: string;
}

export interface FailStepResponse {
}

export interface CreateStepRequest {
  taskId: string;
  stepKey: string;
}

export interface CreateStepResponse {
  stepId: string;
}

function createBaseSubmitTaskRequest(): SubmitTaskRequest {
  return { workflowName: "", input: new Uint8Array(0) };
}

export const SubmitTaskRequest = {
  encode(message: SubmitTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.workflowName !== "") {
      writer.uint32(10).string(message.workflowName);
    }
    if (message.input.length !== 0) {
      writer.uint32(18).bytes(message.input);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workflowName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTaskRequest {
    return {
      workflowName: isSet(object.workflowName) ? globalThis.String(object.workflowName) : "",
      input: isSet(object.input) ? bytesFromBase64(object.input) : new Uint8Array(0),
    };
  },

  toJSON(message: SubmitTaskRequest): unknown {
    const obj: any = {};
    if (message.workflowName !== "") {
      obj.workflowName = message.workflowName;
    }
    if (message.input.length !== 0) {
      obj.input = base64FromBytes(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTaskRequest>, I>>(base?: I): SubmitTaskRequest {
    return SubmitTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTaskRequest>, I>>(object: I): SubmitTaskRequest {
    const message = createBaseSubmitTaskRequest();
    message.workflowName = object.workflowName ?? "";
    message.input = object.input ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitTaskResponse(): SubmitTaskResponse {
  return { taskId: "" };
}

export const SubmitTaskResponse = {
  encode(message: SubmitTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTaskResponse {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: SubmitTaskResponse): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTaskResponse>, I>>(base?: I): SubmitTaskResponse {
    return SubmitTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTaskResponse>, I>>(object: I): SubmitTaskResponse {
    const message = createBaseSubmitTaskResponse();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseGetTaskStatusRequest(): GetTaskStatusRequest {
  return { taskId: "" };
}

export const GetTaskStatusRequest = {
  encode(message: GetTaskStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskStatusRequest {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: GetTaskStatusRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskStatusRequest>, I>>(base?: I): GetTaskStatusRequest {
    return GetTaskStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskStatusRequest>, I>>(object: I): GetTaskStatusRequest {
    const message = createBaseGetTaskStatusRequest();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseGetTaskStatusResponse(): GetTaskStatusResponse {
  return { status: 0, output: new Uint8Array(0), error: new Uint8Array(0) };
}

export const GetTaskStatusResponse = {
  encode(message: GetTaskStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.output.length !== 0) {
      writer.uint32(18).bytes(message.output);
    }
    if (message.error.length !== 0) {
      writer.uint32(26).bytes(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskStatusResponse {
    return {
      status: isSet(object.status) ? taskStatusFromJSON(object.status) : 0,
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
      error: isSet(object.error) ? bytesFromBase64(object.error) : new Uint8Array(0),
    };
  },

  toJSON(message: GetTaskStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = taskStatusToJSON(message.status);
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    if (message.error.length !== 0) {
      obj.error = base64FromBytes(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskStatusResponse>, I>>(base?: I): GetTaskStatusResponse {
    return GetTaskStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskStatusResponse>, I>>(object: I): GetTaskStatusResponse {
    const message = createBaseGetTaskStatusResponse();
    message.status = object.status ?? 0;
    message.output = object.output ?? new Uint8Array(0);
    message.error = object.error ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelTaskRequest(): CancelTaskRequest {
  return { taskId: "" };
}

export const CancelTaskRequest = {
  encode(message: CancelTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTaskRequest {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: CancelTaskRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTaskRequest>, I>>(base?: I): CancelTaskRequest {
    return CancelTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTaskRequest>, I>>(object: I): CancelTaskRequest {
    const message = createBaseCancelTaskRequest();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseCancelTaskResponse(): CancelTaskResponse {
  return { success: false };
}

export const CancelTaskResponse = {
  encode(message: CancelTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTaskResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CancelTaskResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTaskResponse>, I>>(base?: I): CancelTaskResponse {
    return CancelTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTaskResponse>, I>>(object: I): CancelTaskResponse {
    const message = createBaseCancelTaskResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetStepResultRequest(): GetStepResultRequest {
  return { taskId: "", stepKey: "" };
}

export const GetStepResultRequest = {
  encode(message: GetStepResultRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStepResultRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStepResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStepResultRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
    };
  },

  toJSON(message: GetStepResultRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStepResultRequest>, I>>(base?: I): GetStepResultRequest {
    return GetStepResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStepResultRequest>, I>>(object: I): GetStepResultRequest {
    const message = createBaseGetStepResultRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    return message;
  },
};

function createBaseGetStepResultResponse(): GetStepResultResponse {
  return { found: false, status: "", output: new Uint8Array(0) };
}

export const GetStepResultResponse = {
  encode(message: GetStepResultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    if (message.output.length !== 0) {
      writer.uint32(26).bytes(message.output);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStepResultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStepResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.output = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStepResultResponse {
    return {
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
    };
  },

  toJSON(message: GetStepResultResponse): unknown {
    const obj: any = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStepResultResponse>, I>>(base?: I): GetStepResultResponse {
    return GetStepResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStepResultResponse>, I>>(object: I): GetStepResultResponse {
    const message = createBaseGetStepResultResponse();
    message.found = object.found ?? false;
    message.status = object.status ?? "";
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSaveStepResultRequest(): SaveStepResultRequest {
  return { taskId: "", stepKey: "", output: new Uint8Array(0) };
}

export const SaveStepResultRequest = {
  encode(message: SaveStepResultRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    if (message.output.length !== 0) {
      writer.uint32(26).bytes(message.output);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveStepResultRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveStepResultRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.output = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveStepResultRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
    };
  },

  toJSON(message: SaveStepResultRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveStepResultRequest>, I>>(base?: I): SaveStepResultRequest {
    return SaveStepResultRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveStepResultRequest>, I>>(object: I): SaveStepResultRequest {
    const message = createBaseSaveStepResultRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSaveStepResultResponse(): SaveStepResultResponse {
  return { stepId: "" };
}

export const SaveStepResultResponse = {
  encode(message: SaveStepResultResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepId !== "") {
      writer.uint32(10).string(message.stepId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SaveStepResultResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSaveStepResultResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stepId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SaveStepResultResponse {
    return { stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : "" };
  },

  toJSON(message: SaveStepResultResponse): unknown {
    const obj: any = {};
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SaveStepResultResponse>, I>>(base?: I): SaveStepResultResponse {
    return SaveStepResultResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SaveStepResultResponse>, I>>(object: I): SaveStepResultResponse {
    const message = createBaseSaveStepResultResponse();
    message.stepId = object.stepId ?? "";
    return message;
  },
};

function createBaseFailStepRequest(): FailStepRequest {
  return { taskId: "", stepKey: "", error: "" };
}

export const FailStepRequest = {
  encode(message: FailStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailStepRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: FailStepRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailStepRequest>, I>>(base?: I): FailStepRequest {
    return FailStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailStepRequest>, I>>(object: I): FailStepRequest {
    const message = createBaseFailStepRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseFailStepResponse(): FailStepResponse {
  return {};
}

export const FailStepResponse = {
  encode(_: FailStepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailStepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FailStepResponse {
    return {};
  },

  toJSON(_: FailStepResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FailStepResponse>, I>>(base?: I): FailStepResponse {
    return FailStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailStepResponse>, I>>(_: I): FailStepResponse {
    const message = createBaseFailStepResponse();
    return message;
  },
};

function createBaseCreateStepRequest(): CreateStepRequest {
  return { taskId: "", stepKey: "" };
}

export const CreateStepRequest = {
  encode(message: CreateStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStepRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
    };
  },

  toJSON(message: CreateStepRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStepRequest>, I>>(base?: I): CreateStepRequest {
    return CreateStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStepRequest>, I>>(object: I): CreateStepRequest {
    const message = createBaseCreateStepRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    return message;
  },
};

function createBaseCreateStepResponse(): CreateStepResponse {
  return { stepId: "" };
}

export const CreateStepResponse = {
  encode(message: CreateStepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stepId !== "") {
      writer.uint32(10).string(message.stepId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateStepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stepId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateStepResponse {
    return { stepId: isSet(object.stepId) ? globalThis.String(object.stepId) : "" };
  },

  toJSON(message: CreateStepResponse): unknown {
    const obj: any = {};
    if (message.stepId !== "") {
      obj.stepId = message.stepId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateStepResponse>, I>>(base?: I): CreateStepResponse {
    return CreateStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateStepResponse>, I>>(object: I): CreateStepResponse {
    const message = createBaseCreateStepResponse();
    message.stepId = object.stepId ?? "";
    return message;
  },
};

/** Task queue management */
export interface AgentService {
  SubmitTask(request: SubmitTaskRequest): Promise<SubmitTaskResponse>;
  GetTaskStatus(request: GetTaskStatusRequest): Promise<GetTaskStatusResponse>;
  CancelTask(request: CancelTaskRequest): Promise<CancelTaskResponse>;
  /** Step memoization */
  GetStepResult(request: GetStepResultRequest): Promise<GetStepResultResponse>;
  CreateStep(request: CreateStepRequest): Promise<CreateStepResponse>;
  SaveStepResult(request: SaveStepResultRequest): Promise<SaveStepResultResponse>;
  FailStep(request: FailStepRequest): Promise<FailStepResponse>;
}

export const AgentServiceServiceName = "duraflow.AgentService";
export class AgentServiceClientImpl implements AgentService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AgentServiceServiceName;
    this.rpc = rpc;
    this.SubmitTask = this.SubmitTask.bind(this);
    this.GetTaskStatus = this.GetTaskStatus.bind(this);
    this.CancelTask = this.CancelTask.bind(this);
    this.GetStepResult = this.GetStepResult.bind(this);
    this.CreateStep = this.CreateStep.bind(this);
    this.SaveStepResult = this.SaveStepResult.bind(this);
    this.FailStep = this.FailStep.bind(this);
  }
  SubmitTask(request: SubmitTaskRequest): Promise<SubmitTaskResponse> {
    const data = SubmitTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitTask", data);
    return promise.then((data) => SubmitTaskResponse.decode(_m0.Reader.create(data)));
  }

  GetTaskStatus(request: GetTaskStatusRequest): Promise<GetTaskStatusResponse> {
    const data = GetTaskStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTaskStatus", data);
    return promise.then((data) => GetTaskStatusResponse.decode(_m0.Reader.create(data)));
  }

  CancelTask(request: CancelTaskRequest): Promise<CancelTaskResponse> {
    const data = CancelTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelTask", data);
    return promise.then((data) => CancelTaskResponse.decode(_m0.Reader.create(data)));
  }

  GetStepResult(request: GetStepResultRequest): Promise<GetStepResultResponse> {
    const data = GetStepResultRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStepResult", data);
    return promise.then((data) => GetStepResultResponse.decode(_m0.Reader.create(data)));
  }

  CreateStep(request: CreateStepRequest): Promise<CreateStepResponse> {
    const data = CreateStepRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateStep", data);
    return promise.then((data) => CreateStepResponse.decode(_m0.Reader.create(data)));
  }

  SaveStepResult(request: SaveStepResultRequest): Promise<SaveStepResultResponse> {
    const data = SaveStepResultRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SaveStepResult", data);
    return promise.then((data) => SaveStepResultResponse.decode(_m0.Reader.create(data)));
  }

  FailStep(request: FailStepRequest): Promise<FailStepResponse> {
    const data = FailStepRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FailStep", data);
    return promise.then((data) => FailStepResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
