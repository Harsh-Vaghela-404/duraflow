// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: agent.service.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";

export const protobufPackage = "duraflow";

/** Task lifecycle: PENDING → RUNNING → COMPLETED/FAILED/CANCELLED */
export enum TaskStatus {
  TASK_STATUS_UNSPECIFIED = 0,
  PENDING = 1,
  RUNNING = 2,
  COMPLETED = 3,
  FAILED = 4,
  CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function taskStatusFromJSON(object: any): TaskStatus {
  switch (object) {
    case 0:
    case "TASK_STATUS_UNSPECIFIED":
      return TaskStatus.TASK_STATUS_UNSPECIFIED;
    case 1:
    case "PENDING":
      return TaskStatus.PENDING;
    case 2:
    case "RUNNING":
      return TaskStatus.RUNNING;
    case 3:
    case "COMPLETED":
      return TaskStatus.COMPLETED;
    case 4:
    case "FAILED":
      return TaskStatus.FAILED;
    case 5:
    case "CANCELLED":
      return TaskStatus.CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskStatus.UNRECOGNIZED;
  }
}

export function taskStatusToJSON(object: TaskStatus): string {
  switch (object) {
    case TaskStatus.TASK_STATUS_UNSPECIFIED:
      return "TASK_STATUS_UNSPECIFIED";
    case TaskStatus.PENDING:
      return "PENDING";
    case TaskStatus.RUNNING:
      return "RUNNING";
    case TaskStatus.COMPLETED:
      return "COMPLETED";
    case TaskStatus.FAILED:
      return "FAILED";
    case TaskStatus.CANCELLED:
      return "CANCELLED";
    case TaskStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SubmitTaskRequest {
  workflowName: string;
  /** JSON-encoded */
  input: Uint8Array;
}

export interface SubmitTaskResponse {
  taskId: string;
}

export interface GetTaskStatusRequest {
  taskId: string;
}

export interface GetTaskStatusResponse {
  status: TaskStatus;
  /** JSON-encoded */
  output: Uint8Array;
  /** JSON-encoded */
  error: Uint8Array;
}

export interface CancelTaskRequest {
  taskId: string;
}

export interface CancelTaskResponse {
  /** False if already completed/failed */
  success: boolean;
}

/** Step operations for memoization and crash recovery */
export interface GetStepRequest {
  taskId: string;
  stepKey: string;
}

export interface GetStepResponse {
  found: boolean;
  completed: boolean;
  /** JSON-encoded, only set if completed */
  output: Uint8Array;
}

export interface CompleteStepRequest {
  taskId: string;
  stepKey: string;
  /** JSON-encoded */
  output: Uint8Array;
}

export interface CompleteStepResponse {
  success: boolean;
}

export interface FailStepRequest {
  taskId: string;
  stepKey: string;
  /** JSON-encoded */
  error: Uint8Array;
}

export interface FailStepResponse {
  success: boolean;
}

function createBaseSubmitTaskRequest(): SubmitTaskRequest {
  return { workflowName: "", input: new Uint8Array(0) };
}

export const SubmitTaskRequest = {
  encode(message: SubmitTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.workflowName !== "") {
      writer.uint32(10).string(message.workflowName);
    }
    if (message.input.length !== 0) {
      writer.uint32(18).bytes(message.input);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workflowName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.input = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTaskRequest {
    return {
      workflowName: isSet(object.workflowName) ? globalThis.String(object.workflowName) : "",
      input: isSet(object.input) ? bytesFromBase64(object.input) : new Uint8Array(0),
    };
  },

  toJSON(message: SubmitTaskRequest): unknown {
    const obj: any = {};
    if (message.workflowName !== "") {
      obj.workflowName = message.workflowName;
    }
    if (message.input.length !== 0) {
      obj.input = base64FromBytes(message.input);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTaskRequest>, I>>(base?: I): SubmitTaskRequest {
    return SubmitTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTaskRequest>, I>>(object: I): SubmitTaskRequest {
    const message = createBaseSubmitTaskRequest();
    message.workflowName = object.workflowName ?? "";
    message.input = object.input ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSubmitTaskResponse(): SubmitTaskResponse {
  return { taskId: "" };
}

export const SubmitTaskResponse = {
  encode(message: SubmitTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SubmitTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitTaskResponse {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: SubmitTaskResponse): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitTaskResponse>, I>>(base?: I): SubmitTaskResponse {
    return SubmitTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitTaskResponse>, I>>(object: I): SubmitTaskResponse {
    const message = createBaseSubmitTaskResponse();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseGetTaskStatusRequest(): GetTaskStatusRequest {
  return { taskId: "" };
}

export const GetTaskStatusRequest = {
  encode(message: GetTaskStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskStatusRequest {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: GetTaskStatusRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskStatusRequest>, I>>(base?: I): GetTaskStatusRequest {
    return GetTaskStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskStatusRequest>, I>>(object: I): GetTaskStatusRequest {
    const message = createBaseGetTaskStatusRequest();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseGetTaskStatusResponse(): GetTaskStatusResponse {
  return { status: 0, output: new Uint8Array(0), error: new Uint8Array(0) };
}

export const GetTaskStatusResponse = {
  encode(message: GetTaskStatusResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.output.length !== 0) {
      writer.uint32(18).bytes(message.output);
    }
    if (message.error.length !== 0) {
      writer.uint32(26).bytes(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetTaskStatusResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTaskStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.output = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTaskStatusResponse {
    return {
      status: isSet(object.status) ? taskStatusFromJSON(object.status) : 0,
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
      error: isSet(object.error) ? bytesFromBase64(object.error) : new Uint8Array(0),
    };
  },

  toJSON(message: GetTaskStatusResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = taskStatusToJSON(message.status);
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    if (message.error.length !== 0) {
      obj.error = base64FromBytes(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTaskStatusResponse>, I>>(base?: I): GetTaskStatusResponse {
    return GetTaskStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTaskStatusResponse>, I>>(object: I): GetTaskStatusResponse {
    const message = createBaseGetTaskStatusResponse();
    message.status = object.status ?? 0;
    message.output = object.output ?? new Uint8Array(0);
    message.error = object.error ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCancelTaskRequest(): CancelTaskRequest {
  return { taskId: "" };
}

export const CancelTaskRequest = {
  encode(message: CancelTaskRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelTaskRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTaskRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTaskRequest {
    return { taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "" };
  },

  toJSON(message: CancelTaskRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTaskRequest>, I>>(base?: I): CancelTaskRequest {
    return CancelTaskRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTaskRequest>, I>>(object: I): CancelTaskRequest {
    const message = createBaseCancelTaskRequest();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseCancelTaskResponse(): CancelTaskResponse {
  return { success: false };
}

export const CancelTaskResponse = {
  encode(message: CancelTaskResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelTaskResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelTaskResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CancelTaskResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CancelTaskResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CancelTaskResponse>, I>>(base?: I): CancelTaskResponse {
    return CancelTaskResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CancelTaskResponse>, I>>(object: I): CancelTaskResponse {
    const message = createBaseCancelTaskResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseGetStepRequest(): GetStepRequest {
  return { taskId: "", stepKey: "" };
}

export const GetStepRequest = {
  encode(message: GetStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStepRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
    };
  },

  toJSON(message: GetStepRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStepRequest>, I>>(base?: I): GetStepRequest {
    return GetStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStepRequest>, I>>(object: I): GetStepRequest {
    const message = createBaseGetStepRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    return message;
  },
};

function createBaseGetStepResponse(): GetStepResponse {
  return { found: false, completed: false, output: new Uint8Array(0) };
}

export const GetStepResponse = {
  encode(message: GetStepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.found !== false) {
      writer.uint32(8).bool(message.found);
    }
    if (message.completed !== false) {
      writer.uint32(16).bool(message.completed);
    }
    if (message.output.length !== 0) {
      writer.uint32(26).bytes(message.output);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.found = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.completed = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.output = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStepResponse {
    return {
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
      completed: isSet(object.completed) ? globalThis.Boolean(object.completed) : false,
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
    };
  },

  toJSON(message: GetStepResponse): unknown {
    const obj: any = {};
    if (message.found !== false) {
      obj.found = message.found;
    }
    if (message.completed !== false) {
      obj.completed = message.completed;
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStepResponse>, I>>(base?: I): GetStepResponse {
    return GetStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStepResponse>, I>>(object: I): GetStepResponse {
    const message = createBaseGetStepResponse();
    message.found = object.found ?? false;
    message.completed = object.completed ?? false;
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCompleteStepRequest(): CompleteStepRequest {
  return { taskId: "", stepKey: "", output: new Uint8Array(0) };
}

export const CompleteStepRequest = {
  encode(message: CompleteStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    if (message.output.length !== 0) {
      writer.uint32(26).bytes(message.output);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompleteStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.output = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteStepRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
      output: isSet(object.output) ? bytesFromBase64(object.output) : new Uint8Array(0),
    };
  },

  toJSON(message: CompleteStepRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    if (message.output.length !== 0) {
      obj.output = base64FromBytes(message.output);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompleteStepRequest>, I>>(base?: I): CompleteStepRequest {
    return CompleteStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompleteStepRequest>, I>>(object: I): CompleteStepRequest {
    const message = createBaseCompleteStepRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    message.output = object.output ?? new Uint8Array(0);
    return message;
  },
};

function createBaseCompleteStepResponse(): CompleteStepResponse {
  return { success: false };
}

export const CompleteStepResponse = {
  encode(message: CompleteStepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CompleteStepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompleteStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompleteStepResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: CompleteStepResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompleteStepResponse>, I>>(base?: I): CompleteStepResponse {
    return CompleteStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompleteStepResponse>, I>>(object: I): CompleteStepResponse {
    const message = createBaseCompleteStepResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseFailStepRequest(): FailStepRequest {
  return { taskId: "", stepKey: "", error: new Uint8Array(0) };
}

export const FailStepRequest = {
  encode(message: FailStepRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.stepKey !== "") {
      writer.uint32(18).string(message.stepKey);
    }
    if (message.error.length !== 0) {
      writer.uint32(26).bytes(message.error);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailStepRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailStepRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.stepKey = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.error = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailStepRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      stepKey: isSet(object.stepKey) ? globalThis.String(object.stepKey) : "",
      error: isSet(object.error) ? bytesFromBase64(object.error) : new Uint8Array(0),
    };
  },

  toJSON(message: FailStepRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.stepKey !== "") {
      obj.stepKey = message.stepKey;
    }
    if (message.error.length !== 0) {
      obj.error = base64FromBytes(message.error);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailStepRequest>, I>>(base?: I): FailStepRequest {
    return FailStepRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailStepRequest>, I>>(object: I): FailStepRequest {
    const message = createBaseFailStepRequest();
    message.taskId = object.taskId ?? "";
    message.stepKey = object.stepKey ?? "";
    message.error = object.error ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFailStepResponse(): FailStepResponse {
  return { success: false };
}

export const FailStepResponse = {
  encode(message: FailStepResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FailStepResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFailStepResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FailStepResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: FailStepResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FailStepResponse>, I>>(base?: I): FailStepResponse {
    return FailStepResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FailStepResponse>, I>>(object: I): FailStepResponse {
    const message = createBaseFailStepResponse();
    message.success = object.success ?? false;
    return message;
  },
};

/** Task queue management */
export interface AgentService {
  SubmitTask(request: SubmitTaskRequest): Promise<SubmitTaskResponse>;
  GetTaskStatus(request: GetTaskStatusRequest): Promise<GetTaskStatusResponse>;
  CancelTask(request: CancelTaskRequest): Promise<CancelTaskResponse>;
  /** Step operations for SDK crash recovery */
  GetStep(request: GetStepRequest): Promise<GetStepResponse>;
  CompleteStep(request: CompleteStepRequest): Promise<CompleteStepResponse>;
  FailStep(request: FailStepRequest): Promise<FailStepResponse>;
}

export const AgentServiceServiceName = "duraflow.AgentService";
export class AgentServiceClientImpl implements AgentService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AgentServiceServiceName;
    this.rpc = rpc;
    this.SubmitTask = this.SubmitTask.bind(this);
    this.GetTaskStatus = this.GetTaskStatus.bind(this);
    this.CancelTask = this.CancelTask.bind(this);
    this.GetStep = this.GetStep.bind(this);
    this.CompleteStep = this.CompleteStep.bind(this);
    this.FailStep = this.FailStep.bind(this);
  }
  SubmitTask(request: SubmitTaskRequest): Promise<SubmitTaskResponse> {
    const data = SubmitTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubmitTask", data);
    return promise.then((data) => SubmitTaskResponse.decode(_m0.Reader.create(data)));
  }

  GetTaskStatus(request: GetTaskStatusRequest): Promise<GetTaskStatusResponse> {
    const data = GetTaskStatusRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTaskStatus", data);
    return promise.then((data) => GetTaskStatusResponse.decode(_m0.Reader.create(data)));
  }

  CancelTask(request: CancelTaskRequest): Promise<CancelTaskResponse> {
    const data = CancelTaskRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CancelTask", data);
    return promise.then((data) => CancelTaskResponse.decode(_m0.Reader.create(data)));
  }

  GetStep(request: GetStepRequest): Promise<GetStepResponse> {
    const data = GetStepRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStep", data);
    return promise.then((data) => GetStepResponse.decode(_m0.Reader.create(data)));
  }

  CompleteStep(request: CompleteStepRequest): Promise<CompleteStepResponse> {
    const data = CompleteStepRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CompleteStep", data);
    return promise.then((data) => CompleteStepResponse.decode(_m0.Reader.create(data)));
  }

  FailStep(request: FailStepRequest): Promise<FailStepResponse> {
    const data = FailStepRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FailStep", data);
    return promise.then((data) => FailStepResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
